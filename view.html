<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LP Frontend — HTML/CSS/JS (Server + Local fallback)</title>
  <style>
    *,*::before,*::after{box-sizing:border-box}
    :root{--accent:#2563eb;--muted:#6b7280;--card:#fff;--border:#e6edf3}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:18px;background:#f7fafc;color:#0f172a}
    h2{margin:0 0 12px;font-size:20px}
    .card{background:var(--card);border:1px solid var(--border);padding:12px;border-radius:8px;box-shadow:0 1px 2px rgba(12,20,30,0.03)}
    label{display:block;color:var(--muted);font-size:13px;margin-bottom:6px}
    input[type=number],input[type=text],select{padding:8px;border-radius:6px;border:1px solid #e2e8f0;font-size:14px}
    button{background:var(--accent);color:#fff;border:0;padding:8px 12px;border-radius:6px;cursor:pointer}
    button.secondary{background:#fff;color:var(--accent);border:1px solid #c7defe}
    .layout{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap}
    .left{width:420px;min-width:300px}
    .right{flex:1 1 480px;min-width:320px}
    .constraints{display:flex;flex-direction:column;gap:8px;margin-top:8px}
    .constraint-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;padding:6px 0;border-radius:6px}
    .constraint-row input[type=number].a,
    .constraint-row input[type=number].b,
    .constraint-row input[type=number].c{flex:0 0 88px;min-width:64px}
    .constraint-row .label-mid{font-size:14px;color:var(--muted);flex:0 0 auto}
    .constraint-row .remove{margin-left:auto;flex:0 0 auto;background:#fff;color:var(--accent);border:1px solid #c7defe;padding:6px 8px;border-radius:6px;cursor:pointer}
    @media(max-width:420px){.left{width:100%}.constraint-row .remove{margin-left:0;margin-top:6px}}
    canvas{background:#fff;border:1px solid var(--border);border-radius:6px;display:block;width:100%;height:auto}
    pre{background:#0b1220;color:#e6eef8;padding:10px;border-radius:6px;overflow:auto}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .ranges{margin-top:10px;color:var(--muted);font-size:13px;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .small{font-size:13px;color:var(--muted)}
  </style>
</head>
<body>
  <h2>Linear Programming — frontend → Python solver (with fallback)</h2>

  <div class="layout">
    <div class="left">
      <div class="card">
        <label for="endpoint">Endpoint</label>
        <input id="endpoint" type="text" value="http://127.0.0.1:5000/solve" style="width:100%" />

        <hr style="margin:12px 0;border:none;height:1px;background:var(--border)">

        <label>Objective Z = p·x + q·y</label>
        <div style="display:flex;gap:8px;align-items:center">
          <input id="p" type="number" value="1000" step="any" style="width:100px" />
          <span class="small">x +</span>
          <input id="q" type="number" value="2400" step="any" style="width:100px" />
          <select id="optType" style="margin-left:6px"><option value="min">min</option><option value="max">max</option></select>
          <div style="margin-left:auto"><button id="loadExample" class="secondary">Load example</button></div>
        </div>

        <hr style="margin:12px 0;border:none;height:1px;background:var(--border)">

        <label>Constraints (a·x + b·y ≤ c)</label>
        <div id="constraintsList" class="constraints"></div>

        <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap;">
          <button id="addConstraint" class="secondary">Add constraint</button>
          <button id="send">Send to server & Plot</button>
          <button id="clear" class="secondary">Clear</button>
        </div>

        <div class="ranges">
          <div>X range <input id="xrange" type="text" value="-10,30" style="width:120px;margin-left:6px"></div>
          <div>Y range <input id="yrange" type="text" value="-10,30" style="width:120px;margin-left:6px"></div>
        </div>

        <div style="margin-top:8px" class="small">Если сервер недоступен, фронтенд автоматически выполнит локальную версию решателя.</div>
      </div>
    </div>

    <div class="right">
      <div class="card" style="padding:10px">
        <canvas id="plot" width="800" height="520"></canvas>
      </div>

      <div style="height:12px"></div>

      <div class="card" style="padding:10px;margin-top:8px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div class="small">Solution</div>
            <div id="solutionText" style="font-weight:600;margin-top:6px">—</div>
          </div>
          <div><button id="exportCSV" class="secondary">Export CSV</button></div>
        </div>
        <pre id="rawOutput" style="margin-top:8px;height:160px;">{ }</pre>
      </div>
    </div>
  </div>

<script>
  // ---------- UI helpers ----------
  function $(id){ return document.getElementById(id); }

  function createConstraintRow(a=0,b=0,c=0){
    const div = document.createElement('div'); div.className = 'constraint-row';
    div.innerHTML = `
      <input class="a" type="number" step="any" value="${a}" />
      <span class="label-mid">x +</span>
      <input class="b" type="number" step="any" value="${b}" />
      <span class="label-mid">y ≤</span>
      <input class="c" type="number" step="any" value="${c}" />
      <button class="remove">Remove</button>
    `;
    const rem = div.querySelector('.remove');
    rem.addEventListener('click', ()=>div.remove());
    return div;
  }

  function setConstraints(arr){
    const list = $('constraintsList'); list.innerHTML = '';
    arr.forEach(t => list.appendChild(createConstraintRow(t[0], t[1], t[2])));
  }

  function getConstraints(){
    return Array.from(document.querySelectorAll('#constraintsList .constraint-row')).map(r=>{
      return [Number(r.querySelector('.a').value), Number(r.querySelector('.b').value), Number(r.querySelector('.c').value)];
    });
  }

  // ---------- Math core (JS port of Python solver) ----------
  function intersect(line1, line2){
    const [a1,b1,c1] = line1; const [a2,b2,c2] = line2;
    const D = a1*b2 - a2*b1;
    if(Math.abs(D) < 1e-12) return null;
    const x = (c1*b2 - c2*b1) / D;
    const y = (a1*c2 - a2*c1) / D;
    return [x,y];
  }

  function solveLocal(constraints, objective, opts={eps:1e-9}){
    const [p,q] = objective;
    const points = [];
    for(let i=0;i<constraints.length;i++){
      for(let j=i+1;j<constraints.length;j++){
        const pt = intersect(constraints[i], constraints[j]);
        if(pt !== null) points.push(pt);
      }
    }
    for(const [a,b,c] of constraints){
      if(Math.abs(b) > 1e-12){
        const y = c/b; if(y >= -opts.eps) points.push([0,y]);
      }
      if(Math.abs(a) > 1e-12){
        const x = c/a; if(x >= -opts.eps) points.push([x,0]);
      }
    }
    const valid = [];
    for(const [x,y] of points){
      if(x < -opts.eps || y < -opts.eps) continue;
      let ok = true;
      for(const [a,b,c] of constraints){ if(a*x + b*y > c + opts.eps){ ok = false; break; } }
      if(ok) valid.push([Number(x), Number(y)]);
    }
    // uniq
    const uniq = [];
    for(const pnt of valid){ if(!uniq.some(u=>Math.abs(u[0]-pnt[0])<1e-6 && Math.abs(u[1]-pnt[1])<1e-6)) uniq.push(pnt); }
    if(uniq.length === 0) return { status:'infeasible', valid_points:[], best_min_point:null, best_min_value:null, best_max_point:null, best_max_value:null };

    let bestMinVal=null, bestMinPt=null, bestMaxVal=null, bestMaxPt=null;
    for(const [x,y] of uniq){
      const Z = p*x + q*y;
      if(bestMinVal===null || Z < bestMinVal){ bestMinVal = Z; bestMinPt = [x,y]; }
      if(bestMaxVal===null || Z > bestMaxVal){ bestMaxVal = Z; bestMaxPt = [x,y]; }
    }
    return { status:'optimal', valid_points:uniq, best_min_point:bestMinPt, best_min_value:bestMinVal, best_max_point:bestMaxPt, best_max_value:bestMaxVal };
  }

  // Convex hull (Andrew)
  function convexHull(points){
    if(points.length<=1) return points.slice();
    const pts = points.slice().sort((A,B)=> A[0]===B[0]?A[1]-B[1]:A[0]-B[0]);
    const cross = (o,a,b)=> (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0]);
    const lower=[], upper=[];
    for(const p of pts){ while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop(); lower.push(p); }
    for(let i=pts.length-1;i>=0;i--){ const p=pts[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop(); upper.push(p); }
    upper.pop(); lower.pop(); return lower.concat(upper);
  }

  // ---------- Drawing ----------
  function drawPlot(constraints, solution, opts={xrange:[-10,30],yrange:[-10,30]}){
    const canvas = $('plot'), ctx = canvas.getContext('2d');
    const W = canvas.width = canvas.clientWidth * devicePixelRatio;
    const H = canvas.height = Math.round(520 * devicePixelRatio);
    canvas.style.height = '520px';
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,W,H);

    const [xmin,xmax] = opts.xrange, [ymin,ymax] = opts.yrange;
    const sx = x => ((x - xmin)/(xmax - xmin)) * W;
    const sy = y => H - ((y - ymin)/(ymax - ymin)) * H;

    // grid
    ctx.save();
    ctx.fillStyle = '#fff';
    ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = '#eef2ff'; ctx.lineWidth = Math.max(1, 1*devicePixelRatio);
    for(let x = Math.ceil(xmin); x <= Math.floor(xmax); x++){ const px = sx(x); ctx.beginPath(); ctx.moveTo(px,0); ctx.lineTo(px,H); ctx.stroke(); }
    for(let y = Math.ceil(ymin); y <= Math.floor(ymax); y++){ const py = sy(y); ctx.beginPath(); ctx.moveTo(0,py); ctx.lineTo(W,py); ctx.stroke(); }

    // axes
    ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 1.5*devicePixelRatio;
    if(ymin <= 0 && ymax >= 0){ ctx.beginPath(); ctx.moveTo(0, sy(0)); ctx.lineTo(W, sy(0)); ctx.stroke(); }
    if(xmin <= 0 && xmax >= 0){ ctx.beginPath(); ctx.moveTo(sx(0), 0); ctx.lineTo(sx(0), H); ctx.stroke(); }

    // draw constraints (line + faint half-plane)
    constraints.forEach(([a,b,c])=>{
      ctx.strokeStyle = '#c7d2fe'; ctx.lineWidth = 1.4*devicePixelRatio;
      let p1, p2;
      if(Math.abs(b) > 1e-12){ p1 = [xmin, (c - a*xmin)/b]; p2 = [xmax, (c - a*xmax)/b]; }
      else if(Math.abs(a) > 1e-12){ const x0 = c/a; p1 = [x0, ymin]; p2 = [x0, ymax]; }
      else return;
      ctx.beginPath(); ctx.moveTo(sx(p1[0]), sy(p1[1])); ctx.lineTo(sx(p2[0]), sy(p2[1])); ctx.stroke();

      // half-plane polygon intersection with bounding box
      const corners = [[xmin,ymin],[xmax,ymin],[xmax,ymax],[xmin,ymax]];
      const poly = [];
      // corners that satisfy a*x+b*y<=c
      corners.forEach(cor => { if(a*cor[0] + b*cor[1] <= c + 1e-9) poly.push(cor); });
      // intersection with edges
      const edges = [ [[xmin,ymin],[xmax,ymin]], [[xmax,ymin],[xmax,ymax]], [[xmax,ymax],[xmin,ymax]], [[xmin,ymax],[xmin,ymin]] ];
      edges.forEach(edge=>{
        const e0 = edge[0], e1 = edge[1];
        const dx = e1[0]-e0[0], dy = e1[1]-e0[1];
        const denom = a*dx + b*dy;
        if(Math.abs(denom) > 1e-12){
          const t = (c - a*e0[0] - b*e0[1]) / denom;
          if(t >= -1e-9 && t <= 1+1e-9){
            const xi = e0[0] + t*dx, yi = e0[1] + t*dy;
            poly.push([xi, yi]);
          }
        }
      });
      if(poly.length >= 3){
        const hull = convexHull(poly);
        ctx.fillStyle = 'rgba(99,102,241,0.06)'; ctx.beginPath(); ctx.moveTo(sx(hull[0][0]), sy(hull[0][1]));
        for(let i=1;i<hull.length;i++) ctx.lineTo(sx(hull[i][0]), sy(hull[i][1])); ctx.closePath(); ctx.fill();
      }
    });

    // feasible polygon
    if(solution && solution.valid_points && solution.valid_points.length > 0){
      const hull = convexHull(solution.valid_points);
      if(hull.length >= 3){
        ctx.fillStyle = 'rgba(16,185,129,0.12)'; ctx.beginPath(); ctx.moveTo(sx(hull[0][0]), sy(hull[0][1]));
        for(let i=1;i<hull.length;i++) ctx.lineTo(sx(hull[i][0]), sy(hull[i][1]));
        ctx.closePath(); ctx.fill();
        ctx.strokeStyle = 'rgba(16,185,129,0.6)'; ctx.lineWidth = 2*devicePixelRatio; ctx.beginPath(); ctx.moveTo(sx(hull[0][0]), sy(hull[0][1]));
        for(let i=1;i<hull.length;i++) ctx.lineTo(sx(hull[i][0]), sy(hull[i][1])); ctx.closePath(); ctx.stroke();
      }
      ctx.fillStyle = '#065f46';
      solution.valid_points.forEach(([x,y])=>{ ctx.beginPath(); ctx.arc(sx(x), sy(y), 4*devicePixelRatio, 0, Math.PI*2); ctx.fill(); });
    }

    // best points
    if(solution){
      if(solution.best_min_point){ const [x,y] = solution.best_min_point; ctx.fillStyle = '#7c3aed'; ctx.beginPath(); ctx.arc(sx(x), sy(y), 6*devicePixelRatio, 0, Math.PI*2); ctx.fill(); }
      if(solution.best_max_point){ const [x,y] = solution.best_max_point; ctx.fillStyle = '#ef4444'; ctx.beginPath(); ctx.arc(sx(x), sy(y), 6*devicePixelRatio, 0, Math.PI*2); ctx.fill(); }
    }

    // labels (simple ticks)
    ctx.fillStyle = '#0b1220'; ctx.font = `${12*devicePixelRatio}px Inter`;
    for(let x=Math.ceil(xmin); x<=Math.floor(xmax); x++){ const px = sx(x); ctx.fillText(String(x), px+3, sy(0) - 6*devicePixelRatio); }
    for(let y=Math.ceil(ymin); y<=Math.floor(ymax); y++){ const py = sy(y); ctx.fillText(String(y), sx(0)+6*devicePixelRatio, py - 4*devicePixelRatio); }

    ctx.restore();
  }

  // ---------- Server communication with fallback ----------
  async function sendToServerOrFallback(){
    const endpoint = $('endpoint').value.trim();
    const constraints = getConstraints();
    const p = Number($('p').value), q = Number($('q').value);
    const typ = $('optType').value;
    const body = { constraints, objective: [p,q], type: typ };
    $('rawOutput').textContent = 'Sending to ' + endpoint + ' ...';

    // parse ranges
    const xrange = parseRange($('xrange').value, [-10,30]);
    const yrange = parseRange($('yrange').value, [-10,30]);

    try {
      const resp = await fetch(endpoint, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
      if(!resp.ok) throw new Error('Server returned ' + resp.status);
      const json = await resp.json();
      // unify best_point if type provided
      if(typ === 'min' && json.best_min_point){ json.best_point = json.best_min_point; json.best_value = json.best_min_value; }
      if(typ === 'max' && json.best_max_point){ json.best_point = json.best_max_point; json.best_value = json.best_max_value; }
      $('rawOutput').textContent = JSON.stringify(json, null, 2);
      updateSolutionText(json, typ);
      drawPlot(constraints, json, {xrange, yrange});
    } catch(err){
      // fallback to local solver
      $('rawOutput').textContent = 'Server error: ' + err + '\\nUsing local solver...';
      // const local = solveLocal(constraints, [p,q], {eps:1e-9});
      // // pick best according to typ
      // const out = Object.assign({}, local);
      // if(typ === 'min'){ out.best_point = out.best_min_point; out.best_value = out.best_min_value; }
      // else { out.best_point = out.best_max_point; out.best_value = out.best_max_value; }
      // $('rawOutput').textContent = JSON.stringify(out, null, 2);
      // updateSolutionText(out, typ);
      // drawPlot(constraints, out, {xrange, yrange});
    }
  }

  function updateSolutionText(obj, typ){
    if(obj.status === 'infeasible'){ $('solutionText').textContent = 'Infeasible (no feasible points)'; return; }
    if(!obj.best_point){ $('solutionText').textContent = obj.status || '—'; return; }
    const x = Number(obj.best_point[0]).toFixed(6), y = Number(obj.best_point[1]).toFixed(6), v = Number(obj.best_value).toFixed(6);
    $('solutionText').textContent = `${typ.toUpperCase()} best: (${x}, ${y}) → ${v}`;
  }

  function parseRange(str, fallback){ try{ const parts = str.split(',').map(s=>Number(s.trim())); if(parts.length===2 && !isNaN(parts[0]) && !isNaN(parts[1])) return parts }catch(e){} return fallback; }

  // ---------- Export CSV ----------
  function exportCSV(){
    try {
      const obj = JSON.parse($('rawOutput').textContent);
      if(!obj.valid_points || obj.valid_points.length === 0) return alert('No valid_points to export');
      let csv = 'x,y\\n';
      obj.valid_points.forEach(p => csv += `${p[0]},${p[1]}\\n`);
      const blob = new Blob([csv], {type:'text/csv'}); const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'valid_points.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    } catch(e){ alert('Nothing to export'); }
  }

  // ---------- Wire UI ----------
  $('addConstraint').addEventListener('click', ()=> $('constraintsList').appendChild(createConstraintRow(0,0,0)));
  $('loadExample').addEventListener('click', ()=> setConstraints([[1000,2400,12000],[-650,-500,-1600],[650,500,3200],[-500,1300,0]]));
  $('clear').addEventListener('click', ()=>{ $('constraintsList').innerHTML=''; $('rawOutput').textContent=''; $('solutionText').textContent='—'; });
  $('send').addEventListener('click', sendToServerOrFallback);
  $('exportCSV').addEventListener('click', exportCSV);

  // Init defaults and initial solve
  setConstraints([[1000,2400,12000],[-650,-500,-1600],[650,500,3200],[-500,1300,0]]);
  $('optType').value = 'min';
  // initial draw using local solver
  (function init(){
    const c = getConstraints(); const p = Number($('p').value), q = Number($('q').value);
    const sol = solveLocal(c, [p,q]); $('rawOutput').textContent = JSON.stringify(sol, null, 2);
    updateSolutionText(sol, $('optType').value);
    drawPlot(c, sol, {xrange: parseRange($('xrange').value, [-10,30]), yrange: parseRange($('yrange').value, [-10,30])});
  })();
</script>
</body>
</html>